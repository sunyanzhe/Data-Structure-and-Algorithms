# TCP头格式

需要注意几点
1. TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口
2. 一个TCP链接需要四个元组来表示同一个连接（src_ip，src_port，dst_ip，dst_port）准确说是五元组，还有一个是协议。但是因为这是TCP协议，所以，只说四元组
3. 重要的四个东西
  1. Sequence Number是包的序号，用来解决网络包乱序问题
  2. Acknowledgement Number就是ACK——用来确认收到，用来解决不丢包的问题
  3. Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决控流的
  4. TCP Flag，也就是包的类型，主要用于操控TCP的状态机

# TCP的状态机

其实，网络的传输是没有链接的，包括TCP也是一样的，而TCP所谓的‘连接‘，其实只不过是在通讯的双方维护了一个连接状态，让他看上去好像有连接一样。所以，TCP的状态的变换是非常重要的

握手的状态变化

        SYN
发送方 ========> 接收方
SYN_SENT
       SYN+ACK
发送方 <======== 接收方
                SYN_RCVD
        ACK
发送方 ========> 接收方
ESTABLISHED     ESTABLISHED


单方挥手状态

        FIN
发送方 ========> 接收方
FIN_WAIT1
        ACK
发送方 <======== 接收方
FIN_WAIT2       CLOSE_WAIT
        FIN
发送方 <======== 接收方
                LAST_ACK
        ACK
发送方 ========> 接收方
TIME_WAIT
  |
  |2MSL
  |
CLOSE

双方同时挥手
在FIN_WAIT1之后同时进入进入TIME_WAIT等待2MSL之后关闭

另外有几件是需要注意
1. 关于建立连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后，client掉线了，也没失败。于是，server端如果在一定时间内没有收到TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻番，5次的重试时间间隔为1s，2s，4s，8s，16s，一共是31s，第五次发出后还要等32s都知道第5次也超时了，所以，总共需要63s，TCP才会断开这个连接

2. 关于SYN Flood攻击。一些恶意的人为此制造了SYN Flood攻击——给服务器发送一个SYN，就下线，于是服务器需要等待63s之后断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求都不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事情——当SYN队列满了以后，TCP会通过源地址端口、目标地址端口和时间戳打造一个特别的Sequence Number发出去，如果是攻击者则不会响应，如果是正常连接，则会把SYN Cookie发回来，然后服务端可以通过cookie建立连接（即使不再SYN队列中）请注意，请千万别用tcp_syncookies来处理正常的大负载的连接的情况.因为，syncookies是妥协版的TCP并不严谨。对于正常的请求，你应该调整三个TCP可供你选择，第一个是:tcp_synack_retries可以用它来减少重试次数；第二个是:tcp_max_syn_backlog，可以增大SYN连接数；第三个是tcp_abort_on_overflow处理不过来干脆直接拒接连接

3. 关于ISN的初始化。ISN是不能hard code的，不然会出问题——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时client的Sequence Number可能是3，而Server端认为client端的这个号是30了。全乱了。
RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，知道超过2^32，又从0开始，这样，一个ISN的周期大约是4.55小时。
因为假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime，所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN

4. 关于MSL和TIME_WAIT。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是2*MSL（RFC793定义了ML为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接转成CLOSED状态呢？主要有两个原因：1) TIME_WAIT确保有足够的时间让对端收到ACK，如果被动关闭的那方没有收到ACK，如果被动关闭的那方没有收到ACK，就会触发被动端重发FIN移来移去正好2个MSL。 2)有足够的时间容这个连接不会跟后面的连接混在一起（你要知道，有些自作主张的路由器会缓存IP数据包，如果连接被宠用了，那么这些延迟收到的数据包有可能会跟新连接混到一起）

# TCP重传机制

TCP要保证所有的数据都可以到达，所以必须要有重传机制

注意，接收端给发送端的ACK确认只会确认最后一个连续的包，比如，发送端发送了1，2，3，4，5一个五份数据，接收端收到了1，2，于是返回了ack3，然后收到了4（这里3没有收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和AcK是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了

## 超时重传机制
一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack回4——意味着3和4都收到了

但是，这种方式会有严重的问题，因为要死等3，所以会导致4和5即使已经到了，而发送方也完全不知道发生了什么事，因为没有收到ACK，所以，发送方可能悲观的认为也丢了，所以有可能也会导致4和5的重传

对此有两种选择：
1. 一种是仅重传timeout的包，也就是第3份数据
2. 另一种是重传timeout后所有的数据，也就是第3、4、5这三分数据

这两种方式有好也有不好。第一种会节省带宽但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功，总体来说都不好。因为都在等timeout，timeout可能会很长


## 快速重传机制
于是，TCP引入了一种叫做Fast Retransmit的算法，不以时间驱动，而以数据驱动重传。也就是说，如果包没有连续到达，就ack最后那个可能被丢了的包，乳沟发送方连续收到三次相同的ack，就重传，Fast Retransmit的好处是不用等timeout了再重传

比如：如果发送方发出了1、2、3、4、5份数据，第一份先送到了，于是就ack就回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面4和5到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重传2。然后，接收端收到了2，此时3，4，5都收到了，于是ack回6

Fast Retransmit只解决了一个问题，就是timeout的问题，他依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2还是重传#2 #3 #4 #5呢？因为发送端并不清楚这连续的三个ack（2）是谁传回来的？也许发送端发送了20份数据，是#6 #10 #20传来的呢。这样，发送端很可能要重传从2到20这堆数据（这就是某些TCP实际的实现）。可见这是一把双刃剑

## SACK方法
另外一种更好的方式叫做：Selective Acknowledgement（SACK），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎片

这样发送端就可以根据回传的SACK来指导那些数据到了，哪些没到。于是就又花了Fast Retransmit的算法。当然，这个协议需要两边都支持。

这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经包给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化，但是，接收方这么所额螚会有些极端情况，比如要把内存给别的更重要的东西，所以，发送方也不能完全以来SACK，还是要依赖ACK，并维护time-out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack

注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发送一堆SACK的选项，这回导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。

## Duplicate SACK —— 重复收到数据的问题

Duplicate SACK又称D-SACK，其主要是用来了SACK来告诉发送方有哪些数据被重复接收了。
D-SACK使用了SACK的第一个段来做标志
1. 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK
2. 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK

示例
    Transmitted    Received    ACK Sent
    Segment        Segment     (Including SACK Blocks)

    500-999        500-999     1000
    1000-1499      (delayed)
    1500-1999      1500-1999   1000, SACK=1500-2000
    2000-2499      2000-2499   1000, SACK=1500-2500
    2500-2999      2500-2999   1000, SACK=1500-3000
    1000-1499      1000-1499   3000
                   1000-1499   3000, SACK=1000-1500
                                          ---------

下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包出发了‘Fast Retransmit’算法，可以重传，重传时，被延误的包到了，所以回了一个SACK=1000-1500，因为ACK已经到3000了，所以这个SACK是D-SACK——表示收到了重复的包


# RTT算法
什么是RTT，RTT就是数据从网络一端传送到另一端所需要的时间，就是包的往返时间
超时重传时间是以RTO表示
假设在重传的情况下，超时时间RTO「较长或较短」时，都会导致问题
1. 当RTO较大时，重发就慢，丢了半天才重发，没有效率，性能差
2. 当RTO较小时，会导致可能没有丢就重发，于是重发的较快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

因此准确测量超时时间RTO时非常重要的
根据上述两种情况我们可以得知，RTO应该略大于RTT的值
RTO应该时动态变化的值

看一下Linux时如何计算RTO的

估计往返时间，通常需要采样以下两个：
1. 需要TCP通过采样RTT的时间，然后进行加权平均，算出一个平滑RTT的值，这个值时不断变化的，因为网络不断变化
2. 除了采样RTT，还要采样RTT的波动范围，这样就避免如果RTT有一个大的波动的话，很难发现的情况。


# 滑动窗口
窗口的实现实际上时操作系统开辟了一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓存区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除

假设窗口为3个TCP段，那么发送发可以连续发送3个TCP段，并且途中若有ACK丢失，可以通过下一个确认应答进行确认

## 窗口大小由哪一方决定
TCP头里有一个字段叫Window，也就是窗口大小
这个字段是接收端告诉发送端自己还有多少缓冲区接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据而不会的导致接收端处理不过来

所以通常窗口的大小是由接收方的窗口大小来决定的

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据

## 发送方的滑动窗口
1. 发送方已发送并接收到ACK确认的数据
2. 已发送但为接收到ACK确认的数据
3. 未发送但是总大小在接收方处理范围内（接收方还有空间）
4. 未发送但总大小超过接收方处理范围内（接收方没有空间）

指针
1. SND.WND 表示发送窗口的大小
2. SND.UNA 是一个绝对指针，只想已发送但是没有收到确认的第一个序列号
3. SND.NXT 也是一个绝对指针，只想未发送但是可以发送范围的第一个字节的序列号

## 接收方的滑动窗口
1. 已经成功接收并且确认的数据
2. 未收到数据但可以接收的数据
3. 未收到的数据并不可以接收的数据


## 窗口关闭

在前面我们都看到了，TCP通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制

如果窗口大小为0时，就会组织发送方给接收方传递数据，知道窗口变为非0为止，这就是窗口关闭

窗口关闭会有一些潜在的危险

接收方向发送方通告窗口大小时，是通过ACK报文来通告的

那么，点那个发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的ACK报文，如果这个通告窗口的ACK报文在网络中丢失了，那么麻烦就大了

这会导致发送方一直等待接收方的非0窗口通知，接收方一直等待发送方的数据，如不采取措施，这种互相等待的过程，会造成了死锁的现象

为了解决这个问题，TCP为了每个连接设有一个持续定时器，只要TCP接收方一方收到对方的另窗口通知，就会启动持续计时器

如果持续计时器超过，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小

窗口探测
1. 如果接收窗口仍然为0，那么收到这个报文的一方就会重新启动持续计时器
2. 如果接收窗口不是0，那么死锁的局面就可以被打破了

窗口探测的次数一般为3次，每次大约30-60秒（不同的实现可能会不一样）
如果3次过后接收到窗口还是0的话，有的TCP实现就会发RST报文来中断连接

## 糊涂窗口综合症

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小

到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症

要知道，我们的TCP+IP头有40个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了

就好像一个承载50人的大巴车，每次来了一两个人，就直接发车。粗肥家里有矿的大巴司机才敢这么玩，要不迟早破产。要解决这个问题也不难，大巴司机等乘客熟料超过了25个，才认定可以发车


所以，糊涂窗口综合症的现象是可以发生在发送方和接收方
1. 接收方可以通告一个小的窗口
2. 而发送方可以发送小数据

于是，要接觉糊涂窗口正，就要解决上面两个问题就可以了
1. 让接收方不通告小窗口给发送方
2. 让发送方避免发送小数据

通常策略如下
当窗口小于min（MSS，缓存空间/2），也就是小于MSS与1/2缓存大小中的最小值时，就会向发送方通告窗口为0，也就阻止了发送方再发数据过来

等到接收方处理了一些数据之后，窗口大小 >= MSS，或者接收方缓存空间有一般可以使用，就可以把窗口打开让发送方发送数据过来

# 拥塞控制

> 为什么会有拥塞控制，不是已经有了流量控制了吗

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络中发生了什么
一般来说计算机网络都处在一个共享的环境，因此也有可能会因为其他主机之间的通信使得网络拥堵

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包延时、丢失等，这是TCP就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延时已经更多的丢包，这种情况就会进入恶性循环被不断地放大

所以，TCP不能忽略网络上发生的事，它被设计成了一个无私的协议，当网络发送拥塞时，TCP会自我牺牲，降低发送的数据量

于是，就有了拥塞控制，控制的目标就是避免「发送方」的数据填满整个网络

为了在「发送方」调节所要发送数据的量，定义一个叫做「拥塞窗口」的概念

> 什么是拥塞窗口？和发送窗口有什么关系呢

拥塞窗口 cwnd是发送方维护的一个状态变量，他根据网络的拥塞成都动态变化

之前提到过发送窗口swnd和接收窗口rwnd是约等于关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min（cwnd，rwnd），也就是拥塞窗口和接收窗口的最小值

拥塞窗口cwnd变化的规则
1. 只要网络中没有出现拥塞，cwnd就会增大
2. 但网络中出现了拥塞，cwnd就会减少

> 那怎么知道当前网络是否出现了拥塞呢

其实只要「发送方」没有在规定时间内接收到ACK应答报文，也就是发生了超时重传，就会认为网络出现了拥塞

> 拥塞控制有哪些控制算法

1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速恢复

## 慢启动
TCP刚建立连接完成后，首先是有一个慢启动过程，这个慢启动的意思是一点一点提升发送数据包的数量，如果一上来就发大量的数据，会堵塞网络

慢启动的算法规则是：当发送方没收到一个ACK，拥塞窗口cwnd就会加1，也就是手会在一个RTT的时间内*2 成指数增长

> 那么慢启动涨到什么时候是个头呢
有一个慢启动门限ssthresh(slow start threshold) 状态变量
1. 当 cwnd < ssthresh时，就会启用慢启动算法
2. 当 cwnd >= ssthresh时，就会启动拥塞避免算法

## 拥塞避免算法
前面说到，当拥塞窗口cwnd「超过」慢启动门限ssthresh就会进入拥塞避免算法

一般来说ssthresh的大小时65535字节

那么进入拥塞避免算法后，它的规则就是：每当收到一个ACK时，cwnd增加1/cwnd，也就是说在一个RTT的时间内 + 1


## 拥塞发生

当网络出现拥塞，也就是发生数据包重传，重传机制主要有两种

1. 超时重传
2. 快速重传

> 当发生超时重传的拥塞发生算法

当发生了「超时重传」，就会使用拥塞发生算法

这个时候，ssthresh和cwnd的值会发生变化

1. ssthresh的值设为cwnd/2
2. cwnd重置为1


拥塞发送 —— 超时重传

接收就会重新开始慢启动，慢启动是会突然减少数据流的，这真是一旦「超时重传」立马回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿

> 发生快速重传的拥塞算法

还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的ACK，于是发送端就会快速重传，不必等待超时重传

TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，则ssthresh和cwnd变化如下
1. cwnd = cwnd/2，也就是设置为原来的一般
2. ssthresh = cwnd
3. 进入快速恢复算法

## 快速恢复

快速重传和快速恢复算法同时使用，快速恢复算法是认为，你还能收到3个重复ACK说明网络没那么糟糕，没必要像PTO超时那么强烈

正如前面所说，进入快速恢复之前，cwnd和ssthresh已经被更新了
1. cwnd = cwnd/2，也就是设置为原来的一般
2. ssthresh = cwnd

然后，进入快速恢复算法如
1. 拥塞窗口cwnd = ssthresh + 3
2. 重传丢失的数据包
3. 如果在收到重复的ACK，那么cwnd增加1
4. 如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh的值，原因是该ACK确认了新的数据，说明重duplicated ACK时的数据都已经收到，该恢复过程已经结束可以恢复到之前的状态了，也就再次进入拥塞避免状态
