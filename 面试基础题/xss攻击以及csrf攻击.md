# XSS攻击

## 什么是XSS
cross-site Scripting（跨站脚本攻击），是一种代码注入攻击。攻击通过在慕白哦网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全

XSS的本质是：恶意代码未经过滤，与网站的正常代码混在一起；浏览器无法分辨那些脚本是可信的，导致恶意脚本被执行。

而由于直接在用户的终端执行，而已集哦啊笨能够直接获取用户的信息，或者利用信息冒充用户向网站发起攻击者定义的请求

在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略

不仅仅是业务上的‘用户的UGC内容’可以进行注入，包括URL上的参数等都可以是攻击的来源。

## XSS分类

根据攻击的来源，XSS攻击可以分为存储型、反射型和DOM型三种

## 存储型XSS
攻击步骤
1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户欣慰，调用目标网站接口执行攻击者指定的操作

这种攻击常见于带有保存数据功能的网站，如论坛，商品评论，用户私信

## 反射型XSS
攻击步骤
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

反射型XSS跟存储型XSS的区别是：存储型XSS的恶意代码存在数据库里，反射型的XSS的恶意代码存在URL里

反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索，跳转等。

## DOM型XSS
攻击步骤
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL
3. 用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

## 预防方式
服务器再向浏览器注入HTML的时候，采用合适的转义库

Content Security Policy(内容安全策略)
禁止加载外域代码，防止复杂攻击逻辑
禁止外域提交，网站攻击后，用户的数据不会泄露到外域
禁止内联脚本执行
禁止未授权的脚本执行
合理使用上报可以及时发现XSS

HTTP-only Cookie：禁止JavaScript读取某些敏感cookie，攻击者完成XSS注入后也无法窃取此cookie


# CSRF

CSRF(Cross-site request forgery) 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后端的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的

## 流程
1. 受害者登陆a.com 保留了登陆凭证(cookie)
2. 攻击者引诱受害者访问了b.com
3. b.com向a.com发送了一个请求 a.com/act=x。浏览器会默认携带a.com的Cookie
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为受害者自己发送的请求
5. a.com一受害者的名义执行了act=xx
6. 攻击完成，攻击者在受害者不知情的情况下，冒充了受害者，让a.com执行了自己定义的操作


## 防护策略

### 同源检测
在Http协议中，没人格异步请求都会携带两个Header，用于标记来源域名：
1. Origin
2. Referer

这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。服务器

### CSRF Token

由于CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容），仅仅是冒用信息。

那么我们可以要求所有用户请求都携带一个CSRF攻击这无法获取到的Token，服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF攻击

#### 原理
1. 用户打开页面，服务器生成一个token
2. 在页面加载时，使用js遍历整个DOM树，对于DOM中所有的a和fomr标签加入Token
3. 页面提交的请求携带这个Token
4. 服务器验证token是否正确


### Samesite Cookie属性
```http header
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Sanmesite=Lax
Set-Cookie: baz=3
```

我们在a.com下发起对b.com的任意请求，foo这个Cookie都不会包含在Cookie请求头中，但bar会。

Samesite=Lax
这种成为宽松模式： 加入这个请求是改变了当前页面或者打开了新页面，且同时是个GET请求，则这个Cookie可以作为第三方Cookie。

当用户从a.com点击链接进入b.com时，foo这个Cookie不会包含在Cookie请求头中，但是bar和baz会，也就是说用户在不同网站之间通过链接跳转不受影响，但加入这个请求是a.com发起的对b.com的异步请求，或者页面跳转是通过表单的post提交触发的，则bar也不会发送