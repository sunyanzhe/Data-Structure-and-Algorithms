# 强缓存

强缓存不需要http请求

在Http1.0时期，使用的是Expires，在Http1.1中使用的Cache-Control.

## Expires
Expires即过期时间，存在于服务端返回的响应头中，告诉历览器这个时期时间之前可以直接从缓存里面获取数据，无需再次请求。

```http
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在2019年11月22日8点41分过期，过期后需要向服务器发起Http请求

这个问题有一个坑，当服务器的时间和浏览器的时间不一致，那服务器返回的这个过期时间可能就是不准确的。所以在Http1.1版本中被抛弃了


## Cache-Control

在Http1.1中，采用了一个非常关键的字段Cache-Control。

它与Expires本质的不同在于它并没有采用具体的过期时间点，而是采用过期时长来控制缓存，对应的字段是max-age


```
Cache-Control: max-age=3600
```

代表这个响应返回后在3600秒，也就是1个小时之内直接使用缓存

但它不止一个属性，它可以组合非常多的指令
1. public：客户端和代理服务器都可以缓存
2. private： 这种情况只有浏览器能缓存
3. no-cahce：跳过当前的强缓存，发送http请求，即进入协商缓存阶段
4. no-store： 不进行任何形式的缓存
5. s-maxage： 针对代理服务器的缓存时间


# 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存tag向服务器发送请求，有这个服务器根据这个tag，来决定是否使用缓存，这就是协商缓存

具体来说，这样的缓存tag氛围两种：Last-Modified和Etag。这两者各有优劣，并不存在谁对谁有绝对优势，跟上面强缓存的两个tag不一样

## Last-Modified
即最后修改时间，在浏览器第一次给服务器发送请求后，浏览器在响应头中加上这个字段
浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段得知也就是服务器传来的最后修改时间

服务器拿到请求头中的If-Modified-Since字段后，其实回合这个服务器中，该资源的最后修改时间对比：

如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样
否则返回304，告诉浏览器直接使用缓存

## ETag
ETag是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。浏览器通过响应头把这个值给浏览器

浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器

服务器收到If-None-Match后，会跟服务器上该资源的ETag进行比对
如果两者不一样，说明要更新，返回的新资源，跟常规的HTTP请求响应的流程一样
否则返回304，告诉浏览器直接使用缓存

## 对比

1. 在精准度上，ETag优于Last-Modified。由于ETag是按照内容给资源上标识，因此能准确感知资源的变化，而Last-Modified就不一样了，他在一些特殊的情况并不能准确感知资源变化
  编辑了资源文件，但是文件内容并没有修改，这样也会造成缓存失效
  Last-Modified能感知到的单位时间是秒，如果文件在1秒内改变了很多次，就无法体现出修改
2. 在性能上，Last-Modified优于ETag，Last-Modified仅仅知识记录了一个时间点，而ETag需要文件的内容生成的hash值

如果两种方法都支持的话，服务器优先考虑Etag


# 缓存位置

当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。
那这些资源究竟缓存在什么位置呢

浏览器中的缓存位置一共分为四种，按优先级从高到低排列：
1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

## Service Worker
Service Worker借鉴了Web Worker的思路，即让JS运行在主线程之外，由于它脱离了浏览器的的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中离线缓存就是Service Worker Cache

Service Worker同时也是PWA的重要实现机制

## Memory Cache和Disk Cache

Memory Cache指的是内存缓存，从效率上来说它是最快的。但是从存活时间来讲同时最短的，当渲染进程结束后，内存缓存也就不存在了

Disk Cache就是储存在磁盘中的缓存，从存取效率上将是比内存缓存慢的，但是他的又是在于存储容量和存储时长

比较大的JS、CSS文件会直接丢进磁盘，反之丢进内存
内存使用率比较搞的时候，文件优先进入磁盘


## Push Cache