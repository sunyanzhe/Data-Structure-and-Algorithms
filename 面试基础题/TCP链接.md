# 三次握手
1. 客户端发送SYN报文， SYN = 1,seq = x。SYN=1的报文段不能携带数据，但要消耗一个序号

2. 服务器收到SYN报文，以自己的SYN报文作为应答，并制定自己的初始化序列号(y)，同时把客户端的ISN + 1作为ack的值，表示自己已经接收到了客户端的SYN，此时服务器处于SYN_REVD的状态
SYN = 1; ACK = 1; seq = y; ack = x + 1

3. 客户端收到SYN报文后，发送ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文
ACK = 1; seq = x + 1; ack = y + 1


## 为什么是三次握手

假设如果是两次握手的话，
客户端发出链接请求，但因链接请求报文丢失而未收到确认，于是客户端再重新穿了一次链接请求。后来收到了确认，建立了链接。数据传输完毕后，就释放了链接，客户端共发出了两个链接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文知识因为某些网络节点长时间只留了，延误到链接释放后的某个时间才到达服务端，此时服务端误认为客户端又一次发送了链接请求，于是向客户端发出了确认报文段，同意简历链接，不采用三次握手，只要服务端发出确认，就建立新的链接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源


# 四次挥手

1. 第一次挥手：客户端发送FIN报文，报文中会指定一个序列号。此时客户端初始FIN_WAIT1状态

FIN = 1; seq = u

2. 第二次挥手：服务端接收FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表名已经收到客户端的报文，此时服务端处于CLOSE_WAIT状态

ACK = 1; seq = v; ack = u + 1

3. 第三次挥手：如果服务端也想断开链接，和客户端的第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态。
即没有想客户端发出的数据，服务端进入LAST_ACK状态，等待客户端确认

ACK = 1； FIN = 1； seq = w; ack = u + 1

4. 第四次挥手：服务器收到了FIN之后，一样发送ACK报文作为应答，且把服务端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文之后才介入CLOSED状态，服务端收到ACK报文之后，就处于关闭链接了，处于CLOSED状态
即客户端收到服务端的链接释放报文段之后，对此发出确认报文段，客户端进入TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭链接了，处于CLOSED状态

ACK = 1; ack = w + 1; seq = u + 1

## 挥手为什么需要四次
因为当服务端收到客户端的SYN链接请求报文之后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭链接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复ACK报文，告诉客户端，你发的FIN报文我收到了。只有等到我服务端所有的报文都发送完了，我才能发送FIN包围，因此不能一起发送。故需要四次挥手

## 2MSL等待状态
TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL，它是任何报文段丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
对一个具体时间所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超市并重发最后的FIN）

这种2MSL等待的另一个结果是这个TCP链接在2MSL等待时间，定义这个接口的查扣不能在被使用。这个链接只能在2MSL结束后才能在被使用

## 四次挥手释放链接时，等待2MSL的意义

MSL（Max）的意思是`最长报文段寿命`，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重新传这个FIN-ACK，接着客户端在重新传一次确认，重新启动时间等待计时器。最后客户端和服务端都能正常的关闭。假设客户端不等待2MSL，而是发送完ACK之后直接释放关闭，一旦ACK丢失的话，服务器就无法正常进入关闭链接状态

两个理由：
保证客户端发送的最后一个ACK报文段能够到达服务端
这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的取人，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放链接，则无法收到客户端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入CLOSED状态。

防止‘已经失效的链接请求报文段’出现在本链接中
客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本链接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的链接中不会出现这种旧的链接请求报文段。

