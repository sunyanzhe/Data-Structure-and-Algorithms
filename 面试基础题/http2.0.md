# 什么事http/2协议

1. 对1.x协议的语义的完全兼容
http/2协议是在1.x基础上的升级而不是重写，1.x协议的方法，状态以及api在2.0协议里是一样的

2. 性能的大幅提升
http/2协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能优化

# http/2优化内容

## 二进制分帧(Binary Format) - http/2的基石

http2.0之所以能够突破http1.x标准的性能限制，改进传输性能，实现低延迟的高吞吐量，就是因为增加了二进制分帧层

帧（frame）包含部分：类型Type，长度Length，标记Flags，流标识Stream和frame payload有效载荷

消息（message）：一个完整的请求或响应，比如请求、响应等，由一个或多个Frame组成

流（stream）：连接中的一个虚拟信道，可以承载双向消息传输，每个流有唯一整数标识符，为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务端发起的流具有偶数ID

流标识是描述二进制frame的格式，使得每个frame都能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置

这些概念的关系总结如下：
1. 所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流
2. 每条stream都有一个唯一的标识符和可选的优先级信息，用于承载双向消息
3. 每个message都是一条逻辑HTTP消息（例如请求或响应），包括一个或多个帧
4. frame是最小的通信单位，承载特定类型的数据，例如HTTP表头消息负载等等，来此不同数据流的帧交错发送，然后在根据每个帧头的数据流标识符重新组装

虽然看上去协议的格式和http1.x完全不同了，实际上http/2并没有改变http1.x的语义，只是把原来http1.x的header和body部分通过frame重新封装了一层而已，调试的时候浏览器甚至会把http2的frame自动还原成1.x的格式

对于http1.x来说，通过设置tcp segment里的reset flag来通知对端关闭连接。这种方式会直接断开连接，下次在发送请求就会重新建立。http2引入RST_STREAM类型的frame，可以在不断开连接的前提下取消某个request的stream。

# 多路复用
HTTP/1被抱怨更多的就是连接无法复用和队首阻塞这两个问题。理解这两个问题有一个十分重要的前提：客户端依据域名来向服务器建立连接，一般PC端浏览器会针对单个域名的server同时建立6-8个连接，手机端的连接数则一般控制在4-6个，为了突破单域名连接数的限制，这也是为什么CDN站点通常会申请多个静态资源域名

## 连接无法复用
会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下比较明显，TCP慢启动则对文件类大请求影响较大

http1.0协议头里可以设置Connection：keep-alive。可以在一定时间内复用连接

## 队头阻塞

会导致带宽无法被充分利用，以及后续健康请求被阻塞
http/1.0的实现，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response回来之后才逐个发出

在http1.1中，引入了pipeline来解决队头阻塞

请求2，3，4，5不需要等请求1的response返回之后才发出，而是几乎同一时间把request发向了服务器
但是server的response还是要求依次返回，遵循FIFO原则，也就是说如果请求1的response没有回来，2，3，4，5的response也不会送回来

## HTTP/2 多路复用

http2的所有请求都是通过一个TCP连接并发完成的。
同时流还支持优先级和流控制。

将HTTP消息分解成独立的帧，交错发送，然后在另一段重新组装，是HTTP2最重要的一项增强
1. 并行交错地发送多个请求，请求之间互相不影响
2. 并行交错地发送多个响应，响应之间互不干扰
3. 使用一个连接并行发送多个请求和响应
4. 不必再为绕过HTTP/1.x限制而做更多工作
5. 消除不必要的牙齿和提高现有网络容量的利用率，从而减少页面加载时间

HTTP/2中的新二进制分帧层解决了HTTP/1.x中存在的队首阻塞问题，也解决了并行处理和发送请求及响应时对多个连接的依赖

# Server Push
服务端能够更快的把资源推送给客户端，例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML在发送这些请求，当客户端需要的时候，他已经在客户端了

所有服务器推送数据流都有PUSH_PROMISE帧发起，表明了服务器向客户端推送所述资源的意图，并且需要优先请求推送资源响应数据传输。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。满足次要求的最简单策略是优先父响应发送所有PUSH_PROMISE帧

假设服务端收到客户端HTML请求，决定用server push推送一个css文件。
那么服务端会构造一个请求，包括请求方法和请求头，填充到一个PUSH_PROMISE帧中发送个客户端，来告诉客户端他已经代劳发了这个请求。
如果此时客户端需要请求这个文件，即使服务端还没推万，他也不会网服务端发送对CSS文件的请求

这个栗子中，必须先发送PUSH_PROMISE，再发送HTML的内容，这是因为HTML中存在对CSS的引用，一旦客户端发现了这个引用却还没有收到PUSH_PROMISE，他就会发起获取CSS文件请求

# HPACK头部压缩
在HTTP1.x中，此元数据始终以纯文本形式，通常会给每个传输增加500-800字节的开销，如果使用HTTP Cookie，增加的开销有时可能会到上千字节

为了减少此开销和提升性能，HTTP/2使用HPACK压缩格式压缩请求和响应标头部元数据，这种格式采用了两种技术

